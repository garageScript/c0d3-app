---
title: Classes
order: 3
---

# Table of Contents

# Class Objects

Now that we've learned some fundamentals of CSS and HTML layout, we'll turn our
attention back to JavaScript to learn a powerful new way of creating objects.

In the last lesson, we learned about how to create a simple object using `{}`.
We had to create each object from scratch. As our programs get more complex,
we'll need a way of making templates that let us quickly create multiple,
similar objects. These are called **classes** (no relation to HTML classes).
Just like how you follow a blueprint to build a house, you use a class to create
an object.

In this lesson, we will learn how to create a class using `function`, and then
use the keyword `new` to create an object from the class.

Objects are heavily used in games. When logic is complex, we use detailed
objects to simplify the code.

<twoColumns>

<div>

This game might use a "character" object to give every character certain
properties (life counter, for example) and functions (such as attack and move).

After each character is created, it can be customized to have different
properties or functions from the other characters (clothing, defense mechanism,
etc.)

</div>

<Image
  src="/assets/curriculum/lessons/js4/game.jpg"
  height="945"
  width="1680"
/>

</twoColumns>

To define a class, we simply write a function using the `function` keyword. This
function can take in arguments to help create the object.

- When the function runs, `this` refers to the new object being created, so all
  keys for `this` are set as keys for the object.

```jsx
function Soldier(name, age) {
  this.age = age

  let life = 100
  this.getName = () => {
    return name
  }
  this.getLife = () => {
    return life
  }
  this.getHurt = () => {
    if (age > 25) {
      life = life - 10
    }
    life = life - 10
  }
}
```

To create an object from the class, you run the function with the keyword `new`
in front. You can create as many objects as you want.

```jsx
const a = new Soldier('Bunny', 20)
const b = new Soldier('Scooby', 11)
const c = new Soldier('Tigger', 40)

a.age // 20
b.age // 11
c.age // 40

a.getLife() // returns 100
c.getName() // returns "Tigger"

a.getHurt()
c.getHurt()

a.getLife() // returns 90
b.getLife() // returns 100
c.getLife() // returns 80
```

Notice how we used a few different methods of setting variables in the Soldier
class.

<twoColumns>

<div>

For age we set `this.age` to `age` (argument), which makes the variable directly
accessible. If this were a game in a web application, the player could type
`this.age` on the console to find or even modify the Soldier's age.

For life we used `let` along with **getter and setter functions**.

Usually, you don't want to set properties to `this` in an object, especially if
they contain sensitive data. Otherwise the player could write `a.life = 1000` in
the console to give themselves more lives!

We didn't need to explicitly set `name`, because it's an argument and will be
available as long as each Solider lives (closure).

</div>

<Image
  src="/assets/curriculum/lessons/js4/inspect.png"
  height="504"
  width="463"
/>

</twoColumns>

Using classes helps you organize your code better. In web design, you should
always try to use classes when you have to create multiple elements with the
same functionalities. If you are asked to build a complex HTML page during an
interview, your first instinct should be to think about what classes you should
create to simplify the problem.

> JavaScript class has nothing to do with an HTML tag's class attribute. Be
> careful not to confuse the two!

## Example

This section will go through an engineer's thought process to
**[create a moving circle where the user clicks](https://songz.c0d3.com/js4/examples/circles.html)**.

**Steps**

1. Should you use a JavaScript class? Yes. Every time you click on the page, you
   create a circle object, so we'll want a Circle class.
   - The code to move the circle will be inside the class function.
2. The first thing we need is an element that covers the whole page so we can
   click on it. When a click event is detected, we console.log the `x` and `y`
   position of the mouse.

   ```jsx
   <div class="screen"></div>
   <style>
   .screen{
     position: fixed;
     top: 0px;
     bottom: 0px;
     left: 0px;
     right: 0px;
     background-color: rgba(200,255,255, 1);
   }
   </style>
   <script>
   const main = document.querySelector('.screen')

   main.addEventListener('click', (e) => {
   	console.log('x position is', e.clientX)
   	console.log('y position is', e.clientY)
   })
   </script> ****
   ```

3. Add in the CSS for a circle, and write the Circle class.

   Note that we'll also be using the CSS version of "class" hereâ€”similar
   concept, but no relation to our JavaScript Circle class.

   When a Circle object is created, we need to create a `div` element for it,
   give the div a `circle` class in CSS, set its `top` and `left` properties,
   and append it to the main element. Since each circle has a width and height
   of `100px`, in order to place its _center_ at the requested coordinates we
   need to move it up and left by `50px`.

   ```jsx
   <style>
   ...
   .circle {
     border-radius: 50%;
     width: 100px;
     height: 100px;
     border: 2px rgba(0,0,0,1) solid;
     background: rgba(0,255,255,1);
     position: fixed;
   }
   </style>
   <script>
   const main = document.querySelector('.screen')
   function Circle (x, y) {
     y = y-50
     x = x-50
     const element = document.createElement('div')
     element.classList.add('circle')
     element.style.top = `${y}px`
     element.style.left = `${x}px`
     main.append(element)
   }
   main.addEventListener('click', (e) => {
     new Circle(e.clientX, e.clientY)
   })
   </script>
   ```

4. Now we need to make the circle move up. We create a function called `moveUp`
   that will update the `y` variable, set the `top` property of the element, and
   then call setTimeout to wait 200ms.

   `moveUp` will be called every 200ms, forever.

   ```jsx
   function Circle (x, y) {
     ...
     const moveUp = () => {
       y = y-20
       element.style.top = `${y}px`
       setTimeout(moveUp, 200)
     }
     moveUp()
   }
   ```

5. Unfortunately, if you keep clicking for a few minutes and create many
   elements, you will notice your computer getting slower. This is because even
   though each circle has disappeared from the screen, the computer is still
   calculating its position and updating the CSS. To fix this problem, we remove
   the element when the `y` position becomes smaller than 0.

   ```jsx
   const moveUp = () => {
     y = y - 20
     if (y < 0) {
       return element.remove()
     }
     element.style.top = `${y}px`
     setTimeout(moveUp, 200)
   }
   ```

   Since you cannot see `y < 0`, you could set the condition check to `y < 100`
   to visually see the elements are getting removed to make sure your code
   works, then change it back to `y < 0`.

### Exercises

1. [Modify the previous video caption](https://songz.c0d3.com/js4/exercises/vidCaption2.html)
   exercises to use class objects when a caption is created.

<Spoiler name="EMPTY Overview"> </Spoiler>

2. [Create circles that starts with 10 lives](https://songz.c0d3.com/js4/exercises/circleLife.html).
   When you click on the circle, the circle's life goes down. When the circle's
   life hits 0, the circle disappears.

<Spoiler name="Hint: `event.stopPropagation()`">

event.stopPropagation(): Prevents the event from bubbling up the DOM tree,
preventing any parent handlers from being notified of the event. Here in this
task, it will help to only trigger one effect instead of two when you make a
click. For instance, when you click the circle whose life is 9, it will make its
life down 1 to 8 (this current event) without generating another circle on the
screen (the parent handler being notified). Or when life of the circle will be
down to 0 once clicked, it will remove the circle without generating another
circle at the same place with life at 10.

</Spoiler>

<Spoiler name = "EMPTY OVERVIEW">

**HTML**

a. Create a screen `div`. Select it.

**CSS**

b. Create a class for your screen and circle.

- The css should be the example same as the example but the position of the
  circle should absolute.

**JavaScript**

c. Create a Circle class that passes in x and y coordinates.

- Create a `number` variable and set it to 10.
- Assign y to y minus 50.
- Assign x to x minus 50.
- Create and `div` element and add a circle class.
- Assign the `div`'s style top to the y coordinate + px (for pixels) coordinate
  and the left to the x coordinate + px.

3. Create a Circle class that passes in x and y coordinates.

- Create a `number` variable and set it to 10.
- Assign y to y minus 50.
- Assign x to x minus 50.
- Create and `div` element and add a circle class.
- Assign the `div`'s style top to the y coordinate + px (for pixels) coordinate
  and the left to the x coordinate + px.

</Spoiler>

3. [Create an `nxn` box creator](https://songz.c0d3.com/js4/exercises/rowGen.html).
   Type in a number and a box that many boxes square is created.

<Spoiler name = "Hint">

- How could we modify the previous 20x20 grid exercise?
- You'll want to use an object to represent the little boxes. Even though it
  takes a little extra code in part 1, it will be worth it when you get to
  part 2.

</Spoiler>

<Spoiler name = "Overview">

**HTML**

1. Create a container `div` and an number `input` tag.

**CSS**

2. Create a class for square `divs` that has a display of inline-block, border,
   height and width of 50px.

- Create a row class that has a display of flex.

**JavaScript**

3. Select the container `div` and an number `input` number.

c. Create a function called `generateRows(row, rowDiv, i=0)` that passes in rows
and a DOM element to append to.

- When it is run, it creates a `div` and gives it the CSS class of square.
- Append it to the DOM element.
- Keep iterating for as long as the rows variable.

4. Create a function called `grid(rows, cols, j=0)` that passes in rows and
   columns.

- When it is run, create a `div` and give it the CSS class of row.
- Run `generateRows(rows, rowDiv)`.
- Append rowDiv to your container element and keep iterating until index is
  cols.

5. Create a keyup event listener for the `input` number.

- If the event is a number less than 900, set the container's innerHTML to an
  empty string.
- Then run `grid(+num.value, +num.value)`.

6. Check whether the input is a positive integer. If not, then display "Please
   input a valid value: nonzero number" without generating any boxes. Since the
   demo code does not include this part, you can figure it out yourself easily.

</Spoiler>

- **Part 2:**
  [Add the ability to click to reveal row and column numbers](https://songz.c0d3.com/js4/exercises/rowGen2.html).

  When other elements are empty and your div has text, you may notice your
  element gets pushed down. To fix this, make sure your box element has the
  following CSS property:

  ```css
  vertical-align: top;
  ```

<Spoiler name = "Overview">

6. Modify your `generateRows()` function to also pass in your index from
   `grid()` function.

- add a click event listener to the `div` you created inside `generateRows()`
  function. When clicked set the innerHTML of the div to both indexes from your
  functions.

</Spoiler>

<Spoiler name = "Debrief">

Let's go through the steps of how a software engineer would solve this problem.

1. Should you use a class? Yes. You have a visible object (the box) that will be
   created many times, all with shared functionality.
2. First we create the HTML (only 2 lines) and use CSS to say what we want each
   box to look like.
3. Write the Box class. Each box should:
   - Make itself a corresponding `div` element with the `box` CSS class
   - Hide its text by default
   - Give itself a click listener to toggle whether the text is shown or hidden.
     Note that because of closure, we know this function will always be able to
     access the row, column, and shown/hidden status, which are defined in its
     calling function.
   - Add itself to the container
4. From here you just have to make a function to create n x n boxes. As far as
   the CSS is concerned, there's no need to keep track of rows and
   columnsâ€”setting the width of `container` and displaying the boxes as
   `inline-block` makes sure there will only be n boxes to a row. But we chose a
   recursive function that made it easier to pass a row and column number in
   when creating each Box object.

- When we started adding more functionality to the boxes, it made more sense to
  define them as objects. What extra code would be needed if we _hadn't used_
  objects?

</Spoiler>

4. [Display characters and all configurations](https://songz.c0d3.com/js4/exercises/warMap.html)
   given the CSS file.

   [https://songz.c0d3.com/js4/exercises/war.css](https://songz.c0d3.com/js4/exercises/war.css)

   Add the css to your file, then create `div` elements for each character. Try
   to make your page look like the demo page.

   - You need to add the CSS that helps give the character animation.
   - When you add this CSS, you can add classes to your elements to display the
     character.

<Spoiler name = "Overview of KeyFrames">

<Image
  src="/assets/curriculum/lessons/js4/keyframes.png"
  width="667"
  height="905"
/>

`@keyframes` is just a syntax to define animations

It allows you to build really cool animations. Not important to know unless you
actually work in animations.

</Spoiler>

<Spoiler name = "Hint">

Import the [War CSS](https://songz.c0d3.com/js4/exercises/war.css) library the
same way you would an external stylesheet and then select divs based on their
class.

```html
<link rel="stylesheet" href="https://songz.c0d3.com/js4/exercises/war.css" />
<div class="character"></div>
```

</Spoiler>

<Spoiler name = "Overview">

**Version 1.0 Brute Force**

**CSS**

1. Create a row class then set the width to 100%, display flex, position, and
   justify-content.

2. Create a square class then set the position and padding to bottom.

and a square class.

3. Select all `p` paragraph elements and set the color to maroon.

**HTML**

4. Create a title `h1` for class name, an `h3` title for warrior. Then create
   four rows.
5. The first row should four `div` elements:

- One `div` with a square, character and up class
- One `div` with a square, character and down
- One `div` with a square, character and left
- One `div` with a square, character and right

6. The second row should have four paragraph elements with a lower class:

- One `p`'s innerText should be .character.warrior.up
- One `p`'s innerText shoud be .character.warrior.down
- One `p`'s innerText should be .character.warrior.left
- One `p`'s innerText should be .character.warrior.right

7. A `h3` title for the peasant and the third row should have four `div`
   elements:

- One `div` should have a square, character and up class
- One `div` should have a square, character and down
- One `div` should have a square, character and left
- One `div` should have a square, charcter and right

8. The fourth row should have four paragraph elements:

- One `p`'s innerText should be .character.up
- One `p`'s innerText shoud be .character.down
- One `p`'s innerText should be .character.left
- One `p`'s innerText should be .character.right

**JavaScript**

9. Create a function called solution that querySelects all warrior and lower
   classes.

10. Create a setTimeout function that iterates over the warrior classes.

- if the element contains attack class then remove it
- else add an attack class

11. Iterate over the lower classes

- if the element contains attack class
- grab the result of the element's innerText and split it at '.'
- pop off the result array
- set the InnerText to the result array joined at '.'
- remove attack class
- otherwise, add an attack string to the element's innerText
- add an attack class

12. call solution and set the timeout to 1000

13. initialize solution()

**Version 2.0 with Class**

**CSS**

1. Use the previous CSS. Then create a warrior and peasant containers that are
   exactly like the row.

**HTML**

2. Create a warrior container `div` and a peasant container `div` and reuse the
   same paragraph tags HTML for the second and fourth rows.

**JavaScript**

3. Select the warrior and peasant containers.

4. Create a Character class that passes in a direction and whether it is or
   isn't a warrior.

- Create a div and it's a warrior add a square, character, the direction and
  warrior classes to the div.
- Then append it to the warrior container.
- Otherwise add a square, character and direction to the div.
- Then append it to the peasant container.

5. Reuse the same helper function solution.

6. Initialize solution()

7. Create eight new characters with unique directions for warriors and peasants.

</Spoiler>

5. [Create a character on click](https://songz.c0d3.com/js4/exercises/war.html).
   The first click must be a warrior class. Everything else can be a normal
   person class.

   - When the input box (bottom right) is focused, the arrow keys will change
     the direction of the warrior, and pressing `a` will set the character into
     attack sequence.

<Spoiler name = "Overview">

**CSS**

1. Create a square class with a position of absolute.
2. Create a container class and set the position, z-index, top, left, right, and
   bottom attributes.

**HTML**

3. Create a header `h1` and a container `div`. Select them.

**JavaScript** 4. Select the container div and create an index set to zero.

5. Create a Character class that passes in x, y, direction and whether it is a
   warrior.

- Create a div element, set its top to y and left to x
- If it is a warrior, add a square, character, direction and warrior class.
- Append it to the container.
- Otherwise add a square, character and direction class to the div.
- Append it to the container.

6. Add a click event listener to the container that passes in an event.

- if the index is zero, increment the index and create a new character with the
  event's x and y, down direction and warrior
- Otherwise create a new character with the event's x and y, and down.

</Spoiler>

6. [Functional TodoList](https://songz.c0d3.com/js4/exercises/todo1.html).
   Ability to add and remove todo items from the browser.

<Spoiler name = "Hint">

Combine the JavaScript from the JS3 todo list and some of the CSS from the
earlier todo list. Otherwise start from scratch if you feel confident!

</Spoiler>

- Every element has a `querySelector` property function to search for children
  elements. For example:

  ```jsx
  const div = document.createElement('div')
  div.innerHTML = `
    <div>
      <h1> title </h1>
      <button class="clickclick"> Click </button>
  `
  const btn = div.querySelector('.clickclick')
  // btn is the button element inside div
  ```

- Every element has a `remove` property function that removes itself from the
  page. Continuing from the example above, clicking on the button will remove
  the div element from the page.

  ```jsx
  btn.addEventListener('click', () => {
    div.remove()
  })
  ```

<Spoiler name = "Overview">

If you got stuck stop and think. Look at your previous solutions from the JS3
and CSS todo list exercises.

</Spoiler>

## Promises: resolve and reject

When a function (like `fetch`) returns a promise, it is actually returning a new
promise object created from a promise class: `new Promise(...)`.

When you write functions, you can return a promise object too!

Promise takes in one argument, a function: `new Promise( fn )`. The function
should take in two function parameters, called `resolve` and `reject`
respectively. Running `resolve` will run the `then` property of the promise
object.

When your input function runs the `resolve` function, the arguments you pass
into `resolve` will be immediately passed into the `then` callback in the
promise chain.

```jsx
const delayBy = (time, verb) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(verb)
    }, time)
  })
}

delayBy(500, 'study')
  .then(data => {
    console.log(data) // logs "study" after 500ms
    return delayBy(440, 'sleep')
  })
  .then(data => {
    console.log(data) // logs "sleep" after 440ms
    return delayBy(140, 'dance')
  })
  .then(data => {
    console.log(data) // logs "dance" after 140ms
    return 'eat'
  })
  .then(data => {
    console.log(data) // "eat"
  })

// This whole file will take 1130ms to run
// 500 + 440 + 140 = 1130
```

Running `reject` will run the `catch` property of the promise object. You will
run the `reject` function if an error occurs.

```jsx
const delayBy = (time, verb) => {
  return new Promise((resolve, reject) => {
    if (time < 50) {
      return reject('time too small')
    }
    setTimeout(() => {
      resolve(verb)
    }, time)
  })
}

delayBy(49).catch(data => {
  console.log(data) // "time too small"
})
```

<Spoiler name="What this would look like if we chained setTimeouts instead">

```jsx
setTimeout(() => {
  console.log('study')
  setTimeout(() => {
    console.log('sleep')
    setTimeout(() => {
      console.log('dance')
      console.log('eat')
    }, 140)
  }, 440)
}, 500)
```

Notice how much cleaner promises can make this type of code.

</Spoiler>

### Exercises

1. Write a function called `readFile` that reads a file. Unlike `fs.readFile`,
   which uses callbacks, your function should return a promise instead.

   ```jsx
   readFile('./test.js').then(data => {
     console.log(data)
   })
   ```

<Spoiler>

```jsx
const fs = require('fs')

const readFile = filePath => {
  return new Promise((res, rej) => {
    fs.readFile(filePath, (err, data) => {
      if (err) {
        // If there is an error, reject it
        return rej(err)
      }
      res(data)
    })
  })
}
```

</Spoiler>

2. Write a function called `readFiles` that takes in an array of paths and
   returns a promise. The promise resolves with an array of file contents.
   (`The promise resolves with X...` means the function you pass into the `then`
   function will get the X parameter.)

   ```jsx
   readFiles(['./lib.js', './lib.test.js', '~/Documents/notes.txt']).then(
     data => {
       console.log(data[0]) // file contents from lib.js
       console.log(data[1]) // file contents from lib.test.js
       console.log(data[2]) // file contents from ~/Documents/notes.txt
     }
   )
   // Make sure you are resolving in the same order!
   ```

<Spoiler>

Solution 1: This solution creates the promises one at a time and uses `forEach`
on the paths.

```jsx
const fs = require('fs')
const readFiles = paths => {
  const results = new Array(paths.length)
  let finished = 0
  return new Promise((r, j) => {
    paths.forEach((path, i) => {
      fs.readFile(path, (err, data) => {
        results[i] = data
        finished = finished + 1

        if (finished === paths.length) {
          r(results)
        }
      })
    })
  })
}
```

Solution 2: This solution uses the previous answer `readFile` and
`Promise.all([...])` which takes in an array of promises and resolves with an
array of resolved results in corresponding order. Much easier, isn't it?

```jsx
const readFiles = paths => {
  const filePromises = paths.map(path => {
    return readFile(path)
  })
  return Promise.all(filePromises)
}
```

</Spoiler>

3. Write a `fetchData` function that takes in a string (URL) and returns a
   promise that resolves with the data directly, saving the user the step of
   parsing the response from JSON.

   ```jsx
   fetchData('https://c0d3.com/api/lessons').then(data => {
     console.log(data) // data is the lesson array
   })
   ```

   Normally, with `fetch`, you would have to convert from JSON first:

   ```jsx
   fetch('https://c0d3.com/api/lessons')
     .then(r => {
       return r.json()
     })
     .then(data => {
       console.log(data) // data is the lesson array
     })
   ```

<Spoiler>

Since `then` also returns a promise, you can simply return the promise returned
from running `then`.

```jsx
const fetch = require('node-fetch')
const fetchData = url => {
  return fetch(url).then(res => {
    return res.json()
  })
}
```

Alternate answer (also works, but will not pass code review because the code is
harder to read):

```jsx
const fetchData = url => {
  return new Promise((res, _rej) => {
    fetch(url)
      .then(response => response.json())
      .then(parsedData => res(parsedData))
  })
}
```

</Spoiler>

---

# Foundations complete

You have learned all the foundations to go and build things that people can use!
Everything you learn from now on will build on these foundations.

---

# Machine Learning

If you've never heard of Machine Learning before this section check out
[this article](https://leetcode.com/explore/featured/card/machine-learning-101/287/what_is_ml/1617/)
before doing exercises.

## Making Models - Project Supplier Inc

As my dad was learning how to code, I learned more about what he had been doing
in his job for the past two decades. He worked at a supplying company (Supplier
Inc) that buys supplies for ship voyages in southeast Asia.

When I listened and asked questions about his main task, I wondered if
JavaScript could have saved him some time. I wanted to teach him about machine
learning, so I came up with a quick example. It turns out that a couple hours of
coding could do his full-time job in seconds.

### Problem

Ships sometimes sail for weeks non-stop. This means when a ship is in port, it
needs to stock up with massive quantities of food for its next voyage. The ship
sends Supplier Inc an Excel file of everything it needs (beef, lamb, soda, Red
Bull, Oreo cookies, lettuce, etc).

If Supplier Inc buys 100lbs of beef from a store, it will be very expensive.
It's cheaper to find a wholesaler that specializes in each type of food (meat,
veggies, etc.). So Supplier Inc would put all the meat items into an Excel file
and send it to several meat suppliers to get quotes. It would do the same with
veggie items and send to veggie suppliers. The remaining items would be
purchased from stores.

Supplier Inc needs to separate each order into categories: meat, veggies, and
everything else (items that can't be bought in bulk; call it 'store'). My dad
and his peers worked all year round to take these Excel sheets from the ship
captains and sort each item into supplier categories: **VEGGIES.xlsx**,
**MEAT.xlsx**, and **SHOP.xlsx.**

This project showed my dad how a few hundred lines of JavaScript code could
easily replace him and his coworkers' jobs.

### Training the Model

We first started with a sample of the Excel he would receive from a ship.

[provision.xls](vJS%204%20-%20Front%20End%20Engineering%20ebf85ba9b43c4da2acc00228449e2b8d/provision.xls)

<Spoiler name = "Note">

If you don't have Microsoft Excel on your computer you can download
[provision.xls](https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F88068bf6-f27b-4d84-b6ce-67cb28654d01%2Fprovision.xls?table=block&id=477a8f7d-dd3b-4475-b326-211eb283ff99&name=provision.xls&cache=v2)
and upload it to:

[Google Sheets](https://docs.google.com/spreadsheets) If you have a google
account or [iCloud Numbers](https://www.icloud.com/numbers/) or if you have an
iCloud account.

</Spoiler>

After looking at it, we wanted to just pick a few input /output pairs to build a
**model**, which is a set of mathematical equations that can most accurately
give the correct output given a set of inputs. We picked a few from the Excel
above and saved the result into a file. Each key is a random item from the Excel
(input) and the value is the category that it belongs to (output).

Here's the `provisionData.json` file. Case doesn't matter to the model; this is
just how the items are listed in the suppliers' catalogs. Also notice how there
are typos ('lamp' instead of 'lamb'). Hopefully our model will give its best
guess and little typos should not affect the output.

```jsx
{
  "LAMP RUMP (OFFER LAMP LEG) - LAMP LEG": "meat",
  "FROZEN CHICKEN LEG": "meat",
  "CALF'S LIVER - BEEF LIVER": "meat",
  "BEEF SIRLOIN CONTRAFILLET": "meat",
  "BEEF ANTRICOT": "meat",
  "FAT TAIL": "meat",
  "BEEF RUMP": "meat",
  "CHICKEN BREAST": "meat",
  "TOMATO PASTE 830 GR": "veggie",
  "JACKFRUIT": "veggie",
  "CUCUMBER": "veggie",
  "FROZEN SPINACH": "veggie",
  "KETCHUP": "store",
  "PASTA Basedow 4": "store",
  "KIWI FRUIT": "veggie",
  "GRAPES RED": "veggie",
  "GRAPES GREEN": "veggie",
  "JALAPENO PEPPER PICKLE 5 LT": "veggie",
  "WHITE CHEESE EZINE TAHSILDAROGLU 600 GR": "store",
  "RIZE TURIST BLACK TEA 1 KG": "store",
  "DOUGH THIN FOR BAKLAVA 450 GR": "store",
  "TABLE SALT": "store",
  "OLIVE OIL": "store",
  "ROASTED GROUNDNUT 120 GR - 12 PCS": "store",
  "MCVITIE'S DIGESTIVE BISCUITS - DARK CHOCOLATE 24 PCS": "store",
  "BEEF BONELESS SILVER SIDE": "meat"
}
```

JSON files are a bit unforgiving when you make careless mistakes. Make sure the
last value in your object does not have `,`

<Spoiler name = "Alternatively, you can use JavaScript by adding `module.exports = ...` and
  changing the filename to `provisionData.js`">

```jsx
module.exports = {
  'LAMP RUMP (OFFER LAMP LEG) - LAMP LEG': 'meat',
  'FROZEN CHICKEN LEG': 'meat',
  "CALF'S LIVER - BEEF LIVER": 'meat',
  'BEEF SIRLOIN CONTRAFILLET': 'meat',
  'BEEF ANTRICOT': 'meat',
  'FAT TAIL': 'meat',
  'BEEF RUMP': 'meat',
  'CHICKEN BREAST': 'meat',
  'TOMATO PASTE 830 GR': 'veggie',
  JACKFRUIT: 'veggie',
  CUCUMBER: 'veggie',
  'FROZEN SPINACH': 'veggie',
  KETCHUP: 'store',
  'PASTA BASE': 'store',
  'KIWI FRUIT': 'veggie',
  'GRAPES RED': 'veggie',
  'GRAPES GREEN': 'veggie',
  'JALAPENO PEPPER PICKLE 5 LT': 'veggie',
  'WHITE CHEESE EZINE TAHSILDAROGLU 600 GR': 'store',
  'RIZE TURIST BLACK TEA 1 KG': 'store',
  'DOUGH THIN FOR BAKLAVA 450 GR': 'store',
  'TABLE SALT': 'store',
  'OLIVE OIL': 'store',
  'ROASTED GROUNDNUT 120 GR - 12 PCS': 'store',
  "MCVITIE'S DIGESTIVE BISCUITS - DARK CHOCOLATE 24 PCS": 'store',
  'BEEF BONELESS SILVER SIDE': 'meat'
}
```

</Spoiler>

Now comes machine learning! Using the training data above, we tell the computer
to build a **model** that can most accurately place the items into the correct
categories. Then we'll apply the data to categorize new data.

There are many machine learning libraries for JavaScript. For this project, we
will use [brain.js](https://github.com/BrainJS/brain.js).

### Preparing the Code

We'll create a file called `index.js` and look at it in two sections. The first
section will train the model. The steps are:

1. Import two libraries and the training data you prepared above
2. Reorder each row in your training data to the correct format of input and
   output
3. Use the correct data format to create a model

Note that `brain.js` is a node library you can install with `npm i brain.js`,
and then importâ€”not a local JavaScript file, which would look like `./brain.js`.

```jsx
// index.js
const brain = require('brain.js')
const lib = require('./lib.js') // You will need to write this

const trainingData = require('./provisionData.json')
const makeArr = lib.makeTrainingData(trainingData)

const model = new brain.NeuralNetwork()
model.train(makeArr)

...
```

In production settings, companies usually train the model with trillions of data
points. That means the computer needs to try trillions of combinations for each
data point to find the right set of equations for turning the input into the
correct output. Graphics cards are really good at running these computations in
parallel (at the same time). The same high-end graphics cards that gamers love
are also used to power model training in machine learning.

Because of this huge amount of data, model training usually takes a long time,
so you may want to export the model into a file and import it whenever you need
it. This way you don't have to waste time retraining the model training every
time you want to use it.

For this example our dataset is tiny so we can retrain every time our JavaScript
runs.

The next part of the code will use the trained model to categorize new data!

1. Create an object to hold the results. The keys are the names of each group
   (MEAT, VEGGIE, and STORE), and their values will be arrays of data to put in
   the corresponding Excel files.
2. Read the Excel file
3. For each row in the Excel file:
   1. If the row is a header or footer (in other words, without a numbered ID or
      not enough data), put the row into all the groups
   2. If the row is a valid item, use the model to predict which group the item
      should be in
   3. The model returns a confidence score for each group name
   4. Push this item into the correct group
   5. We get the group name with the highest confidence score
      1. If there is no result (the computer cannot determine what the item is)
         then put this item into all the groups
4. For every group (MEAT, VEGGIE, STORE):
   1. Create an Excel file for each group using the key (name of the group) as
      the sheet name and filename

```jsx
// index.js
...

const groups = {
  MEAT: [],
  STORE: [],
  VEGGIE: []
}

const data = lib.getDataFromExcel('./provision.xls')

data.forEach((e, i) => {
  if (e.length < 2 || !Number.isInteger(parseInt(e[0]))) {
    return lib.pushAll(groups, e)
  }
  let brainData = model.run(lib.tokenize(e[2]))
  const val = lib.getMostLikely(brainData)
  if (!val) {
    return lib.pushAll(groups, e)
  }
	if ( !groups[val] )
		groups[val] = []
  groups[val].push([...e])
})

Object.entries(groups).forEach((arr) => {
  lib.createExcel(arr[0], arr[1])
})
```

Once you've typed this code out, you can save it as `index.js` to use later.

> More experienced software engineers can come up with a clear mental model of
> the code above in their head quickly. They can then task junior engineers with
> writing the `lib` library functions to help them grow and gain experience
> writing good code.

Please take the time to correlate each line of the code with the steps above to
understand what it does.

The entire machine learning part of this project is in the code above! It is
very simpleâ€”just train the model and then run the data against the model. In the
exercise below, you will be writing the rest of the helper functions to format
the data and read and write to Excel files.

### xlsx Library

In the first section above, you had to use **TDD** to write a few functions in
`lib.js`. Here, continue from `lib.js` to add the remaining two functions to
read and write Excel files.

We can use the `xlsx` library to work with Excel files. By now you can probably
guess how to install it: `npm install xlsx`

We can import the `xlsx` library to the file:

```jsx
const xlsx = require('xlsx') //not a local .js file
```

Functions we will need to use from the library:

**Getting Data From a File**

- `xlsx.readFile` takes in a string (file path) and returns a workbook object

  - The workbook object has a `Sheets` key. Its value is a Sheet object with the
    sheet name as key.

  Example code:

  ```jsx
  const provision = xlsx.readFile('./provision.xls')
  // To access the PROV sheet from the Excel file: provision.Sheets.PROV
  ```

- `xlsx.utils.sheet_to_json` takes in two arguments: a Sheet object and an
  object that describes the sheet. It returns an array of objects that
  represents each row in the spreadsheet.

  In the example below we will pass in the sheet from the example above and tell
  the function that our sheet's header starts at row 1:

  ```jsx
  xlsx.utils.sheet_to_json(provision.Sheets.PROV, { header: 1 })
  ```

**Writing Data To a File**

- `xlsx.utils.book_new` Creates a new Excel workbook. A workbook can have many
  sheets.

  ```jsx
  const book = xlsx.utils.book_new()
  ```

- `xlsx.utils.json_to_sheet` Creates an Excel worksheet (which you can attach to
  a workbook with the next function we'll see). Takes in two arguments: (1) an
  array of objects for each row in the sheet and (2) an object with information
  about the sheet. In the example below we are putting an empty array into a
  sheet called `hello`.

  ```jsx
  const bookSheet = xlsx.utils.json_to_sheet([], { sheet: 'hello' })
  ```

- `xlsx.utils.book_append_sheet` Takes in three arguments: a workbook object, a
  sheet object, and the name to give the book. This function will attach the
  sheet created above to the book created above. Then it will give the book the
  title `"hello"`.

  ```jsx
  xlsx.utils.book_append_sheet(book, bookSheet, 'hello')
  ```

- `xlsx.writeFile` Writes an Excel workbook to a file. Takes in two arguments,
  an Excel workbook object and a file path to write the data to. In the code
  below, we are writing the book we created above (with the sheet attached) into
  a file called `hello.xlsx`.

  ```jsx
  xlsx.writeFile(book, `./hello.xlsx`)
  ```

**Exercises: Excel Helper Functions**

Add the following functions to your `lib.js` file:

1. `getDataFromExcel` - takes in a string argument (file path) and returns an
   array of objects that represent each row in the file. Assume the sheet is
   called PROV and has a header at row.

<Spoiler>

```jsx
// lib.js
fn.getDataFromExcel = filePath => {
  const workbook = xlsx.readFile(filePath)
  return xlsx.utils.sheet_to_json(workbook.Sheets.PROV, { header: 1 })
}
```

</Spoiler>

2. `createExcel` - takes in two arguments, a string that represents the filename
   and an array of objects that represents each row of the Excel sheet. Your
   function should create a sheet and a book with the name parameter, attach the
   sheet to the book with the name parameter as its title, and write the book
   into a file using name parameter plus .xlsx as the filename.

<Spoiler>

```jsx
// lib.js
fn.createExcel = (name, data) => {
  const book = xlsx.utils.book_new()
  const bookSheet = xlsx.utils.json_to_sheet(data, { sheet: name })
  xlsx.utils.book_append_sheet(book, bookSheet, name)
  xlsx.writeFile(book, `./${name}.xlsx`)
}
```

</Spoiler>

### Putting it All Together

Now that you have your library file `lib.js`, your main JavaScript program
`index.js`, and your training data `provisionData.json`, you're finally ready to
train the model and run it on new data!

Download the data:

[provision.xls](vJS%204%20-%20Front%20End%20Engineering%20ebf85ba9b43c4da2acc00228449e2b8d/provision.xls)

First make sure you've initialized your project with `npm init` and installed
the library:

`npm i brain.js` .

Then run the code: `node index.js`

### Next steps for Supplier Inc

Now that we have the model trained, we can export it to be used later.

```jsx
const modelData = model.toJSON()
fs.writeFile('./filename', JSON.stringify(modelData), () => {})
```

As Supplier Inc gets more supply requests, they load an existing model and keep
training the model with new data to make it better.

```jsx
const brain = require('brain.js')
const model = new brain.NeuralNetwork()

fs.readFile('./filename', (data) => {
  model.fromJSON(json)
  model.train(...) // train more data!
})
```

Full writeup below:

[ML Project - Supplier Inc](https://www.notion.so/ML-Project-Supplier-Inc-8638598f17814cc38934e24253d3a081)

## Using Models

Since models can be exported and shared, there are many open sourced models
trained by researchers and open source organizations for you to use. In this
section we will explore a few using a library called
[ml5.js](https://ml5js.org/).

The following example will help you understand how to work with pre-trained
models. We will start with the following setup code, which will allow us to:

1. Get access to the user's camera
2. Play the webcam video stream into a video element

```jsx
<video class="video" width=640 height=480></video>
<canvas class="canvas" width=640 height=480></canvas>
<button class="convert">GET NOSE</button>

<script>
	const canvasElement = document.querySelector('.canvas')
  const ctx = canvasElement.getContext('2d')
	ctx.strokeStyle = 'red'
	ctx.lineWidth = 15

	const videoElement = document.querySelector('.video')
  const noseButton = document.querySelector('.convert')

  navigator.mediaDevices.getUserMedia({
    video: true, // webcam
    audio: false, // microphone
  }).then((stream) => {
    videoElement.srcObject = stream
    videoElement.play()
  })
</script>
```

Now we can add in our machine learning model to help us detect noses in the
video! The basic steps to integrating with a machine learning model are:

1. Load the model

   ```jsx
   <script src="https://unpkg.com/ml5@0.4.3/dist/ml5.min.js"></script>
   <script>
   let isReady = false

   /*
    load the faceAPI model using the ml5 library
     Landmarks uses the face detection model to
       determine facial features like nose, eyebrows, mouth, etc.
   		To tell the faceAPI to use the landmarks feature, we
   		pass in an object with the `withLandmarks: true` property
   		when running the ml5.faceApi function.
   */
   const faceapi = ml5.faceApi({
     withLandmarks: true,
   }, () => {
     isReady = true
   })
   </script>
   ```

2. Feed the input (video, image, text, etc) into the model.

   ```jsx
   // Make sure the following function is run after the model has been loaded
   faceapi.detect(videoElement, (err, results) => {
     // Always check for errors, or if there are no results
     if (err || !results || !results.length) {
       return
     }
     // First draw the video element into the canvas,
     //     then draw the nose on top of that image
     ctx.drawImage(videoElement, 0, 0)

     /* 
   		results will be an array of objects (faces detected).
   		  Each object will have a key called parts;
   				each part object has a nose property, which is an array of points.
   		We only want the first face's nose array (results[0])
   	*/
     const nosePaths = results[0].parts.nose
     draw(nosePaths)
   })
   ```

3. Draw the output!

   ```jsx
   const draw = pathArr => {
     if (!pathArr.length) {
       return
     }
     ctx.drawImage(videoElement, 0, 0)
     ctx.beginPath()

     const firstPoint = pathArr.shift()
     ctx.moveTo(firstPoint.x, firstPoint.y)
     pathArr.forEach(point => {
       ctx.lineTo(point.x, point.y)
     })
     ctx.stroke()
   }
   ```

You can put all the above code together, organizing it into a functions and
adding a few event listeners, to make this
[nose detection application](https://songz.c0d3.com/js4/ml/face.html).

### Exercise

For these exercises, you must load the `ml5.js` library.

```jsx
<script src="https://unpkg.com/ml5@0.4.3/dist/ml5.min.js"></script>
```

1. [Sentiment Analysis](https://songz.c0d3.com/js4/ml/sentiment.html): Build a
   UI to do sentiment analysis on the input text. This model will look at the
   words, determine if the word has a positive or negative sentiment, and give
   you a value.

   1. When the page loads, first load the `movieReviews` model by calling the
      function:

      ```jsx
      const sentiment = ml5.sentiment('movieReviews', () => {})
      ```

   2. When the user clicks on the button, get the value from the input element
      and run the `predict` function. `result.score` is a sentiment value
      between 0 ("negative") and 1 ("positive").

      ```jsx
      const result = sentiment.predict(inputElement.value)
      if (result.score > 0.8) {
        alert('happy!')
      }
      ```

<Spoiler name = "Hint">

Text Sentiment
[Documentation](https://learn.ml5js.org/docs/#/reference/sentiment)

To get [Emojis](https://emojipedia.org/pile-of-poo/) for the alert. (Put them
inside of a string)

</Spoiler>

<Spoiler name = "Overview">

**CSS**

1. Set the height and width of your textarea elements.

**HTML**

2. Create an `h5` for your title, `textarea` for your input text and a `button`
   to analyze text. Select them by their class.

**JavaScript**

3. Create a click event listener for your analyze button.

- Grab the value of your textarea element.
- Create a result variable that holds `sentiment.predict(inputElement)` on the
  textarea's value.
- If the result's score is over 0.8 alert the thumbs up emoji
- Otherwise alert the poo emoji.

</Spoiler>

2. [Magic Oracle](https://songz.c0d3.com/js4/ml/oracle.html): **Character
   recurrent neural networks** use a model trained with lots of text and a short
   string called the 'seed' to predict what comes next, character by character.
   This application answers questions in the voice of a variety of famous
   authors.

   1. We'll use ml5.js's `charRNN` class. Start by loading the `shakespeare`
      model when the page loads.

      ```jsx
      const charRNN = ml5.charRNN(
        'https://songz.c0d3.com/js4/models/lstm/shakespeare',
        modelLoaded
      )

      // Sample model loaded function
      const modelLoaded = () => {
        console.log('Model Loaded!')
      }
      ```

<Spoiler name = "Optional: JK Rowling, Hemingway, & other models!">

You can use other models to see different generated texts!

- Harry Potter:
  [https://songz.c0d3.com/js4/models/lstm/jkrowling_HP](https://songz.c0d3.com/js4/models/lstm/jkrowling_HP)
- Hemingway:
  [https://songz.c0d3.com/js4/models/lstm/hemingway](https://songz.c0d3.com/js4/models/lstm/hemingway)
- Zora Neale Hurston:
  [https://songz.c0d3.com/js4/models/lstm/zora_neale_hurston](https://songz.c0d3.com/js4/models/lstm/zora_neale_hurston)
- Other models available are `bolano`, `charlotte_bronte`, `darwin`, `dubois`,
  `hemingway`, `jkrowling_HP`, `shakespeare`, `woolf`, and `zora_neale_hurston`.
  - To use one of these, simply replace the last part of the URL with the model
    you want
  - All models are downloaded from
    [here](https://github.com/ml5js/ml5-data-and-models/)

</Spoiler>

2.  When the seed text is ready, call the `generate` function. `generate` takes
    two arguments, an object and a callback function.

    ```jsx
    const data = {
      seed: questionInput.value,
      temperature: 0.6, // measures 'riskiness' of guesses;
      // 0 most conservative, 1 most diverse
      length: 120 // length of output text
    }
    const gotData = (err, res) => {
      // res is an object; console.log it to find how to
      // display the answer text to the user
    }
    charRNN.generate(data, gotData)
    ```

<Spoiler name = "Overview">

</Spoiler>

- **Part 2:** Add controls for the length, temperature, and model.

  - You can use `<input type="range".../>` for the sliders; see
    [this page](https://www.w3schools.com/tags/att_input_type_range.asp) for
    documentation.

<Spoiler name = "Hint: Changing models">

When the user selects a new model you'll have to re-construct the `charRNN`
object. Start by adding a `change` event listener to the model dropdown. You
might have to change the way `charRNN` is declared as well...

</Spoiler>

<Spoiler name="EMPTY OVERVIEW">

</Spoiler>

<Spoiler name = "Debrief">

In the first solution loading the model was easy; we just needed one line of
code that ran once on page load:

```jsx
const charRNN = ml5.charRNN('http://localhost/lstm/shakespeare', modelLoaded)
```

In the solution for this part, we added a `loadModel` function and put this code
inside it. A few other small changes came as a result of this change, such as
moving the declaration of `charRNN`. This is an example of **refactoring**: the
continual process of adjusting code to optimize its readability and organization
without changing its behavior. Often when you add a feature to your code, you'll
see an opportunity to refactor.

This refactor didn't save any lines of code; the original model loading code was
only one line, same as a function call. But it's much better to avoid
duplicating the code. For one thing, `loadModel` is easy to read. For another,
what if the address to the models changed? Now we would only have to update it
in one place.

</Spoiler>

3. [Object Detection](https://songz.c0d3.com/js4/exercises/videoDetect.html):
   Tesla's self-driving cars use object detection models like this example to
   detect objects in their path. Below are a few hints to help you.

   **Note! This exercise requires a server.**

   1. Use the `video` element and add a play button. When users click on the
      play button, video should play.
   2. Load the YOLO ML model. When the model is loaded, run the detect function
      to detect objects.

      ```jsx
      const detect = () => {
      	setTimeout( () => {
      		yolo.detect(err, results) => {
             console.log(results)
      				// look at the results to see what it looks like
      				// Implement the draw function here
      				// After drawing, rerun the detect function!
      		})
        }, 200)
      }

      const yolo = ml5.YOLO( videoElement, () => {
        detect()
      }
      ```

   3. Draw the results! For this, we will be drawing `div` elements with a
      specified width and height.

      ```jsx
      const draw = (arr = []) => {
      	overlayContainer.innerHTML = '' // clearing the container
        arr.forEach( (obj) => {
        	const div = document.createElement('div')
          div.classList.add('box') // so this element gets the css styling
        	div.innerText = obj.label
      		div.style.top = `${obj.y * 360}px` // 360 is the height of the video
      		div.style.left = `${obj.x * 640}px` // 360 is the width of the video
          // width and height of div
      		overlayContainer.append(div)
      	}
      }
      ```

   4. You will notice that the object detection is slow, which is primarily
      because of your `setTimeout`. Instead of waiting, we want to run our
      function immediately after the computer is ready, and to do that we pass
      our function into `requestAnimationFrame` instead of using `setTimeout`.
      Unlike `setTimeout`, `requestAnimationFrame` only takes in one argument,
      the function that you want it to run.

<Spoiler name = "Hint">

YOLO [documentation](https://learn.ml5js.org/docs/#/reference/yolo)

[Video Link](https://songz.c0d3.com/js4/exercises/cars.mp4)

</Spoiler>

<Spoiler name = "EMPTY ANSWER">

</Spoiler>

<ChallengeBar
  href="/curriculum/24"
  description="Complete class related challenges (add class related challenges)"
  title="Master your skill by solving challenges"
/>
